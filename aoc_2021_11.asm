; vim: filetype=rgbds

include "hardware.inc"


SECTION "Header", ROM0[$0000]
    ; Mostly blank space reserved for someday

    ; rst $00
    ds $08 - @, $00
    ; rst $08
    ds $10 - @, $00
    ; rst $10
    ds $18 - @, $00
    ; rst $18
    ds $20 - @, $00
    ; rst $20
    ds $28 - @, $00
    ; rst $28
    ds $30 - @, $00
    ; rst $30
    ds $38 - @, $00
    ; rst $38
    ds $40 - @, $00

    ; V-Blank interrupt
INTVBlank:
    jp INTScreenUpdate
    ds $48 - @, $00

    ; LCDC interrupt
    reti
    ds $50 - @, $00

    ; Timer interrupt
    reti
    ds $58 - @, $00

    ; Serial Com interrupt
    reti
    ds $60 - @, $00

    ; Joypad interrupt
    reti
    ds $0100 - @, $00

EntryPoint:
    nop
    jp Init
    ; Make space for ROM header
    ; Will be generated by rgbfix at the end
    ds $0150 - @, $00


SECTION "Main", ROM0

Init:
    di
._sync
    ; Wait for the vertical blanking interval so that we can disable the LCD.
    ldh a, [rLY]
    cp 144              ; Wait for first frame to draw
    jr c, ._sync        ; carry unset => V-Blank started

    xor a
    ldh [rLCDC], a      ; Disable LCD Controller to access VRAM

    call InitVRAM
    call InitState
    call ShowMatrix

Main:
    ; Core loop of the program. All this does is wait for the next interrupt.
    ld a, LCDCF_ON | LCDCF_BGON
    ldh [rLCDC], a

    ld a, IEF_VBLANK 
    ldh [rIE], a        ; Enable VBlank interrupts handling
    ei                  ; Enable interrupts

.loop:
    call ReadInput

    ldh a, [hStepCount]
    and a
    jr z, .update

    ldh a, [hInput.up]
    and a, INPUT_A
    jr z, .reset
.update
    call UpdateMatrix

.reset
    ldh a, [hInput.up]
    and a, INPUT_START
    jr z, .wait
    call InitState

.wait
    halt                ; Stop CPU until next interupt
    ; There needs to be a NOP after HALT, rgbasm does that for us
    jr .loop            ; Loop forever

InitVRAM:
    ; Clear VRAM
    ld bc, $2000
    ld hl, $8000
    xor a
    call WriteConstant

    ; Set Tilemap 0 to blank (NOT 0)
    ld bc, $400
    ld hl, $9800
    ld a, (vBlankTile - vTilesStart) / 16
    call WriteConstant

    ; Copy the digits character tileset
    ld b, DigitTiles.end - DigitTiles
    ld de, DigitTiles
    ld hl, vDigitTiles 
    call CopyBinShort
   
    ret

InitState:
    xor a
    ldh [hVideoUpdate], a
    ldh [hFlashStackPtr], a
    ldh [hZeroStackPtr], a
    ldh [hFlashCount], a
    ldh [hFlashCount + 1], a
    ldh [hStepCount], a
    ldh [hStepCount + 1], a

    ; Set up our data matrix
    ld b, 100
    ld de, InitialState
    ld hl, wStaging
    call CopyBinShort

    ld a, 1
    ldh [hVideoUpdate], a

    ret

; A:  constant value to write
; BC: write length
; HL: destination address
WriteConstant:
    ld d, a
    ld a, c
    and a
    jr z, .start
    inc b
.start
    ld a, d
.loop
    ldi [hl], a
    dec c
    jr nz, .loop
    dec b
    jr nz, .loop
    ret

; B:  data length
; DE: origin address
; HL: destination address
CopyBinShort:
.loop
    ld a, [de]
    ldi [hl], a
    inc de
    dec b
    jr nz, .loop
    ret

UpdateMatrix:
    ldh a, [hVideoUpdate]
    and a
    ret nz

    ld hl, wStaging
    ld c, 100

.loop_inc
    ld a, [hl]
    inc a
    cp a, 10
    jr c, ._next
    call PushFlash
    call PushZero
    xor a
._next
    ldi [hl], a
    dec c
    jr nz, .loop_inc

    call ProcessFlashes
    call ProcessZeros

    ld c, (hStepCount & $ff) + 1
    call IncrDecimalCounter

    ld a, 1
    ldh [hVideoUpdate], a

    ret

; HL: Address of cell to process
BumpCell:
    ld a, [hl]
    inc a
    cp a, 10
    jr c, .end
    call PushFlash
    call PushZero
    xor a
.end
    ld [hl], a
    ret

PushFlash:
    push hl
    push bc

    ld b, l
    ld c, hFlashStackPtr & $ff
    ld h, wFlashStack >> 8
    jr _StackPush

PopFlash:
    push hl
    push bc

    ld c, hFlashStackPtr & $ff
    ld h, wFlashStack >> 8
    jr _StackPop

PushZero:
    push hl
    push bc

    ld b, l
    ld c, hZeroStackPtr & $ff
    ld h, wZeroStack >> 8
    jr _StackPush

PopZero:
    push hl
    push bc

    ld c, hZeroStackPtr & $ff
    ld h, wZeroStack >> 8
    jr _StackPop

; HL: start address of stack (lower byte assumed zero)
; C: pointer HRAM location
; B: value to store
_StackPush:
    ldh a, [c]
    ld l, a
    ld [hl], b               ; Store the value and bump HL
    inc a
    ldh [c], a    ; Store the new pointer value

    pop bc
    pop hl
    ret

; HL: start address of stack (lower byte assumed zero)
; C: pointer HRAM location
_StackPop:
    ldh a, [c]
    ; Check that pointer is not at zero
    and a
    jr z, .underflow

    dec a
    ld l, a
    ldh [c], a
    ld a, [hl]
    jr .end

.underflow
    ; Set carry flag to warn caller of underflow
    ccf
.end
    pop bc
    pop hl
    ret

; C: HRAM offset of lower byte (big-endian!)
IncrDecimalCounter:
    xor a  ; Clear flags
    ldh a, [c]
    inc a
    daa
    ldh [c], a
    
    push af
    dec c
    pop af

    ldh a, [c]
    adc a, 0
    daa
    ldh [c], a
    ret

; A: Offset value to convert
; Returns: XY value (BCD) in A
OffsetToXY:
    push bc

    ld b, -1  ; Count of tens
    ld c, 10  ; Constant
.loop_10
    sub a, c
    inc b
    jr nc, .loop_10
    add a, c
    ld c, a   ; Count of ones
    ld a, b
    swap a
    add a, c

    pop bc
    ret

; A: XY value (in BCD) to convert
; Returns: offset value in A
XYtoOffset:
    push bc

    ld c, a
    swap a
    and a, $0f
    ld b, a
    xor a
.loop_10
    add a, 10
    dec b
    jr nz, .loop_10
    ld b, a

    ld a, c
    and a, $0f
    add a, b

    pop bc
    ret

ProcessFlashes:
.loop
    call PopFlash
    ret c
    ; Hold offset value in B
    ld b, a  
    
    ld c, (hFlashCount & $ff) + 1
    call IncrDecimalCounter 

    ; E holds the "neighbor bitmask" in XY
    ; 7: -1, -1
    ; 6:  0, -1
    ; 5:  1, -1
    ; 4: -1,  0
    ; 3:  1,  0
    ; 2: -1,  1
    ; 1:  0,  1
    ; 0:  1,  1
    ld e, $ff

    ; D holds XY of cell
    ld a, b
    call OffsetToXY
    ld d, a

.x_test_0
    and a, $0f
    jr nz, .x_test_9
    ; Cannot use neighbors in x-1
    ld a, e
    and a, %01101011
    ld e, a
    jr .y_test_0

.x_test_9
    cp a, 9
    jr c, .y_test_0
    ; Cannot use neighbors in x+1
    ld a, e
    and a, %11010110
    ld e, a

.y_test_0
    ld a, d
    swap a
    and a, $0f
    jr nz, .y_test_9
    ; Cannot use neighbors in y-1
    ld a, e
    and a, %00011111
    ld e, a
    jr .process_neighbors

.y_test_9
    cp a, 9
    jr c, .process_neighbors
    ld a, e
    ; Cannot use neighbors in y+1
    and a, %11111000
    ld e, a

.process_neighbors

    ; +1, +1
    ld a, b
    add a, 11
    ld l, a
    rrc e
    call c, BumpCell
    
    ; 0, +1
    dec l
    rrc e
    call c, BumpCell

    ; -1, +1
    dec l
    rrc e
    call c, BumpCell

    ; +1, 0
    ld a, b
    inc a
    ld l, a
    rrc e
    call c, BumpCell

    ; -1, 0
    dec l
    dec l
    rrc e
    call c, BumpCell

    ; -1, +1
    ld a, b
    sub a, 9
    ld l, a
    rrc e
    call c, BumpCell

    ; -1, 0
    dec l
    rrc e
    call c, BumpCell

    ; -1, -1
    dec l
    rrc e
    call c, BumpCell

    xor a  ; Set carry to zero
    jp .loop

ProcessZeros:
    ld h, wStaging >> 8
.loop
    call PopZero
    ret c
    
    ld l, a
    ld [hl], 0

    jr .loop

ShowMatrix:
    ldh a, [hVideoUpdate]
    and a
    ret z

    ld de, wStaging
    ld hl, $9800  ; Tileset 1

    ld c, 10
.loop_rows
    ; Unrolled loop to make this fit in VBlank
    REPT 10
    ld a, [de]
    ldi [hl], a
    inc de
    ENDR

    ; Go to start of next row
    ld a, c
    ld bc, 22
    add hl, bc
    ld c, a
    dec c
    jr nz, .loop_rows

    ld hl, $9800 + 32 * 11
    ld c, hFlashCount & $ff

    ldh a, [c]
    ld b, a
    swap a
    and a, $0f
    ldi [hl], a
    ld a, b
    and a, $0f
    ldi [hl], a
    inc c

    ldh a, [c]
    ld b, a
    swap a
    and a, $0f
    ldi [hl], a
    ld a, b
    and a, $0f
    ldi [hl], a
    inc c

    ld hl, $9800 + 32 * 12

    ldh a, [c]
    ld b, a
    swap a
    and a, $0f
    ldi [hl], a
    ld a, b
    and a, $0f
    ldi [hl], a
    inc c

    ldh a, [c]
    ld b, a
    swap a
    and a, $0f
    ldi [hl], a
    ld a, b
    and a, $0f
    ldi [hl], a
    inc c

    xor a
    ldh [hVideoUpdate], a

    ret

INTScreenUpdate:
    push af
    push bc
    push de
    push hl
    call ShowMatrix
    pop hl
    pop de
    pop bc
    pop af
    reti

; How many times joystick inputs are read in a row.
; Common GB practice to make inputs values stable.
DEF INPUT_BOUNCE EQU 4

ReadInput:
    ; Read pad values
    ld a, ~ P1F_GET_DPAD
    ldh [rP1], a
    REPT INPUT_BOUNCE
    ldh a, [rP1]
    ENDR

    ; Move pad values to upper 4 bits, store in B
    and a, $0f
    swap a
    ld b, a

    ; Read button values
    ld a, ~ P1F_GET_BTN
    ldh [rP1], a
    REPT INPUT_BOUNCE
    ldh a, [rP1]
    ENDR

    ; Keep button values in lower 4 bits, combine with pad values
    and a, $0f
    or a, b
    ; Complement so that 1 = button pressed
    cpl 

    ; Store new inputs in B, copy previous inputs in C
    ld b, a
    ldh a, [hInput.now]
    ld c, a

    ; Compute new (up) presses
    xor a, b    ; Differences between new and previous
    and a, b    ; Keep only new inputs
    ldh [hInput.up], a

    ; Store new inputs as current inputs
    ld a, b
    ldh [hInput.now], a

    ret


SECTION "Data", ROM0

InitialState:
    db 6, 6, 1, 7, 1, 1, 3, 5, 8, 4
    db 6, 5, 4, 4, 2, 1, 8, 6, 3, 8
    db 5, 4, 5, 7, 3, 3, 1, 4, 8, 8
    db 1, 1, 3, 5, 6, 7, 5, 5, 8, 7
    db 1, 2, 2, 1, 3, 5, 3, 2, 1, 6
    db 1, 8, 1, 1, 1, 2, 4, 3, 7, 8
    db 1, 3, 8, 7, 8, 6, 4, 3, 6, 8
    db 4, 4, 2, 7, 6, 3, 7, 2, 6, 2
    db 6, 7, 7, 8, 6, 4, 5, 4, 8, 6
    db 3, 6, 8, 2, 1, 4, 6, 7, 4, 5

    ; ds 44, 0
    ; db $09
    ; ds 55, $00

DigitTiles:
    incbin "digits.2bpp"
  .end


SECTION "Memory", WRAM0,ALIGN[8]

wStaging:
    ds 100

SECTION "WorkStack", WRAM0,ALIGN[8]

wFlashStack:
    ds $100

wZeroStack:
    ds $100

SECTION "Tiles", VRAM[$9000]

vTilesStart:
vDigitTiles:
    ds DigitTiles.end - DigitTiles

vBlankTile:
    ds 16


SECTION "HighMemory", HRAM

hVideoUpdate:
    ds 1
hFlashStackPtr:
    ds 1
hZeroStackPtr:
    ds 1
hFlashCount:
    ds 2
hStepCount:
    ds 2

; Joystick input registers. A bit set is a button pressed.  
; From 7 to 0: Start, Select, B, A, Down, Up, Left, Right
hInput:

DEF INPUT_START  EQU %10000000
DEF INPUT_SELECT EQU %01000000
DEF INPUT_B      EQU %00100000
DEF INPUT_A      EQU %00010000
DEF INPUT_DOWN   EQU %00001000
DEF INPUT_UP     EQU %00000100
DEF INPUT_LEFT   EQU %00000010
DEF INPUT_RIGHT  EQU %00000001

; Holds the last value of all inputs.
.now
    ds 1
; Inputs that have been enabled since last frame
.up:
    ds 1
